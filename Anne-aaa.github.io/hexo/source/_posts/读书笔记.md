---
title: 《Spring 4.x 企业应用开发实战》读书笔记
date: 2024-05-21 
tags: 后端
---
# 第一章
源代码：https://github.com/seriouszyx/LearnSpring/tree/master/source%20code
http://iteye.com
##### 为什么云的兴起使得消除开发者和运营者的隔阂更重要？
什么是运营者？
- 传统上,开发者和运营者是分开的两个角色。开发者完成应用程序开发后,就把代码交给运营者。运营者需要将代码部署到服务器上,并负责后续的系统运维工作。
1. 云环境下应用程序的复杂性增加。现代软件项目通常依赖数百个外部依赖项和多个关键服务,运行在云端。开发者需要熟悉和管理大量云服务、工具和平台,工作负担加重。这就需要开发者和运营者密切协作,共同分担责任。

2. DevOps文化的兴起。当今科技公司普遍采用"开发者全权负责"的DevOps文化,开发者不仅负责编码,还参与测试、部署、维护等环节。这种共同责任模式要求开发者和运营者的角色高度融合。


##### 什么功能用传统的OOP不易实现，用AOP却可以轻松应对？
- 面向对象编程(OOP)不太擅长处理的是一些与核心业务逻辑无关,但又需要在多个模块中重复出现的代码,我们称之为"横切关注点"。而面向切面编程(AOP)就是为了解决这个问题而诞生的。 AOP主要应用场景包括日志记录,性能统计,安全控制,事务处理,异常处理等等。"这些功能虽然不是核心业务逻辑,但又需要在许多模块中重复实现,使用传统OOP的做法就会导致代码的冗余和低内聚。

IOC和AOP是Spring以来的根本
- 传统编程用new来创建，现在交给Spring容器注入。
- 传统编程中,对象创建对象,并且负责对象的生命周期。而在IOC模式下,由容器控制对象的创建、初始化以及实例的生命周期。对象本身只需要提供标准的构造函数即可。
  ![[Pasted image 20240508151528.png]]


##### 数据访问和集成：
数据有多种表现形式，如数据表、XML、消息。每种数据形式拥有不同的数据访问技术（数据表的访问可以直接通过JDBC，JOOQ，也可以通过Hibernate或MyBatis）
- 这些都是不同的实现技术，但是同样的解决问题。比如不同的测试框架
- Spring建立起了和数据形式及访问技术无关的统一的DAO层
  eg.   首先,定义一个技术无关的DAO接口:
  ```java
  public interface UserDao { List<User> findAll(); User findById(int id); // ... }
  ```
	然后,使用JOOQ实现这个DAO接口

## 第二章
基于Spring的Web应用

JSP是一种动态页面，是传统的MVC，要返回给浏览器的动态页面。
什么是Web容器？
1. Web容器能够解析并执行动态资源(如JSP、Servlet),而不仅仅是返回静态HTML页面。
2. 常见的Web容器有Tomcat、Jetty等,它们通常以嵌入式的方式运行在应用程序中。
3. 在微服务架构中,轻量级的Web容器(如Tomcat)被广泛使用,因为它们占用较少资源,易于部署和集成。

Jetty
- IDEA的免费社区版本本身不直接支持开发Web项目,需要额外配置Web服务器环境。而Jetty作为一个轻量级的嵌入式Web服务器,可以很方便地集成到IDEA中,为Web项目提供运行环境.
- 与传统的Web服务器(如Tomcat)相比,Jetty更加轻量级,占用系统资源更少,启动速度也更快。这使得在开发阶段使用Jetty更加高效

Spring的声明式事务
- Spring的声明式事务管理就像是安排了一个"监工"在旁边监督,确保付款的每个步骤都正确执行。如果中间出现任何问题,这个"监工"会立即停止后续步骤,并让整个过程回到最初状态,避免数据不一致。使用Spring声明式事务,我们不需要手动编写监控和回滚事务的代码,只需在关键的业务方法上标注@Transactional注解,Spring就会自动为这些方法增加事务管理的能力,确保事务either全部成功或全部失败回滚,不会出现中间状态。

## 第三章
Spring Boot
- 内嵌Tomcat和Jetty容器，不需要部署WAR 文件到Web容器就可独立运行 应用

jar包和war包是什么，为什么要将程序打包成他们？
##### 运维功能
- 当应用部署到生产环境时，需要各种运维相关的功能 的支持，如监控应用的各种性能指标、运行信息和应用状态等。SpringBoot 对这些运维监控相关的类库 进 行 了整 合 ， 形 成 了一 个功 能 完 备 和 可 定 制 的 启 动 器 ， 称 为 A c t u a t o r 。
基于Spring Boot应用，添加监控功能非常简单，只需在应用的pom.xml 文件中添 加spring-boot-starter-actuator 依赖即可
- Spring Boot 默认提供的健康检查关键服务。这些服务都可以在 application.properties 的management .health. *选项中进行配置

pom.xml与application.properties
- 1. pom.xml文件: 相当于build.gradle
	 它是Maven项目的核心配置文件,用于定义项目的构建配置。
	  pom.xml文件中包含了项目的依赖库、插件、构建生命周期等信息。
- 2. **application.properties文件**:
	 它是Spring Boot等Java应用程序的配置文件,用于配置应用程序的运行时参数。
	 application.properties文件中包含了数据库连接信息、服务器端口、日志级别等配置项。

## 第四章
IOC：
- IOC这个概念不够清晰，即某 一接又具体实现类的选择控制权从调用类中移除， 转交给第 三方决定，即由Spring容器借由Bean配置来进行控制。
DI：
- 因为IoC确实不够开门见山，因此业界曾进行了广泛的讨论，最终软件界的泰斗级 人物MartinFowler 提出了DI (DependencyInjection，依赖注入)的概念用来代替IoC， 即让调用类对某一接又实现类的依赖关系由第三方 (容器或协作类)注入，以移除调用 类 对 某 一接 又 实 现 类 的 依 赖 。 “ 依 赖 注 入 ” 这 个 名 词 显 然 比 “ 控 制 反 转 ” 直 接 明 了 、 易 于理解。

构造注入 与 属性注入：
- 并非每个场景都需要它的时候，与构造注入它就显得不太妥当，于是用属性注入。属性注入可以有选择地通过Setter 方法完成调用类所需依赖的注入，更加灵活方便。 也就是"按需注入"
```java
//构造注入革席的具体饰演者 
public MoAttack (GeLi geli) {
this.geli = geli;
}
```

```java
//属性注入
public void setGeli (GeLi geli) {
thisgeli = geli;
}
```


JVM
- JVM将Java源代码编译成字节码,然后将字节码解释成机器码,以便在不同的平台上运行。这使得Java程序可以在不同的平台上运行,而不需要重新编译。
- JVM装载类时使用 “全盘负责委托机制”，“ 全盘负责” 是指当一个ClassLoader 装 载 一 个 类 时 ， 除 非 显 式 地 使 用 另一 个 C l a s s L o a d e r ， 该 类 所 依 赖 及 引 用 的 类 也 由 这 个 ClassLoader 载

Jar包
- jar包是由Java语言编写的程序,将其编译后的.class文件和其他必要资源文件打包成一个文件,以便于分发和部署。

ClassLoader:
- 类装载器 就是 寻找类的字节码文件并构造 出 类 在 J V M 内 部 表 示 对 象 的 组 件 。 在 J a v a 中，类装载器把一个类装入J M中。

JDK：
- JDK(Java Development Kit)是Java语言的开发工具包,包含了Java编译器(将Java源代码编译成.class文件,然后执行这些.class文件。)、Java运行时环境(执行Java程序)和其他开发工具(如debugger、profiler)。

BeanFactory 是Spring 框架的基础设 施，面向Spring 本身:ApplicationContext 面向使用Spring 框架的开发者，几乎所有的 应用场合都可以直接使用ApplicationContext 而非底层的BeanFactory


## 第五章
##### 1. 书中用到了1️⃣配置文件来写这个class是一个bean，但实际项目上并没有这样做，而是好像直接用2️⃣注解引入，这是什么意思？
	- 从Spring 2.5开始,引入了基于注解(@Annotation)的配置方式。开发者可以直接在Bean类上使用@Component、@Service、@Repository、@Controller等注解将其声明为Bean,而不需要在XML中重复配置。这种方式更加简洁、高效,也是当前推荐的配置方式。
eg.
```java
import org.springframework.stereotype.Service;

@Service public class UserService { 
	public String getUserName(int userId) { // 查询用户名的逻辑 return "John Doe"; } 
	}
```
通过`@Service`注解,Spring就可以自动扫描到这个类,并将其注册为一个Bean,名称默认为"userService"(类名的第一个字母小写)。接下来,如果我们有另一个组件需要使用UserService,可以使用`@Autowired`注解自动注入:
```java
import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; 
@Component 
public class UserController {
@Autowired
private UserService userService;
public void printUserName(int userId) { 
 String userName = userService.getUserName(userId); System.out.println("User name: " + userName); 
 }
  }
```
1. `@Component`注解将`UserController`标记为一个Bean。
2. `@Autowired`注解自动将`UserService`的Bean注入到`userService`字段中。

通过这种方式,Spring可以自动扫描和注册所有标记了`@Component`、`@Service`等注解的类作为Bean,并自动注入它们之间的依赖关系。

如 果 容 器 中 有 一 个 以 上匹 配 的 B e a n 时 ， 则 可 以 通 过 @ Q u a l i f i e r 注 解 限 定 B e a n 的 名 称，
一般 情 况 下 ， 在 S p r i n g 容 器 中 大 部 分 B e a n 都 是 单 实 例 的 ， 所 以 一般 无 须 通 过@Repository、@Service 等注解的value 属性为Bean 指定名称，也无须使用@Qualifier 注解按名称进行注入。


还可以通过3️⃣@Configuration来为一个POJO 标注为配置类，里面就可以定义@Bean(比如Service Bean, Dao Bean)，以及Bean的实例化逻辑


##### 2. 关于Bean的作用域：
首先要理解"单例模式"，一个类只有一个实例，适合用来管理共享资源。s i n g l e t o n 的 B e a n 在 同 一S p r i n g I o C 容 器 中 只 有 一个 实例。
S p r i n g 的 A p p l i c a t i o n C o n t e x t 容 器 在 启 动 时 ，自 动 实 例 化 所 有 s i n g l e t o n 的Bean 并缓存于容器中。虽然启动时会花费一些时间，但它带来两个好处:首先，对 Bean提前进行实例化操作会及早发现一些潜在的配置问题

在 默 认 情 况 下， S p r i n g 容 器 在 启 动 时 不 实 例 化 p r o t o t y p e 的 B e a n
request作用域
顾 名 思 义 ， r e q u e s t 作 用 域 的 B e a n 对 应 一个 H T T P 请 求 和 生 命 周 期


什么场景下用单例Bean,什么场景下用prototype的bean？
- 想象一下,我们有一个学校,学校里有很多老师和学生。每个老师都有一个自己的教室,里面有一个小黑板。如果我们使用单例bean来表示小黑板,那就意味着所有老师都共享同一个小黑板。这样的话,如果张老师在小黑板上写了"2+3=5",李老师过来上课时,小黑板上还是显示"2+3=5",这就会造成混乱。相反,如果我们使用session bean来表示小黑板,每个老师都会有自己专属的小黑板。这样,张老师在自己的小黑板上写"2+3=5",李老师在自己的小黑板上写"5+7=12",两个老师之间就不会互相影响了。

