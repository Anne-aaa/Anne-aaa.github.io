---
title: 前端项目中遇到的问题
---
1. Node.js：  Node.js则是一个独立的JavaScript运行环境,它可以让JavaScript代码运行在服务器端,而不仅限于浏览器,eg:

    ```jsx
    const http = require('http');
    
    const server = http.createServer((req, res) => {
      res.statusCode = 200;
      res.setHeader('Content-Type', 'text/plain');
      res.end('Hello World');
    });
    
    server.listen(3000, () => {
      console.log('Server running at http://localhost:3000/');
    });
    ```

2. 关于异步：

Jest测试jsx， 其中findAllByText返回的是Promise对象，Promise对象是异步操作的成功或失败的结果。现在加关键字变成同步后，即等到findAllByText全部执行完才往下执行，就能得到list, 从而得到list的length.

这里的mock也值得注意。jest.fn()可以用jest判断调用次数，这里直接用findAllByText就可以不用jest.fn()。

由于我们不关心ProductCard的细节，所以mock这个组件时，可以给一个空的div

```jsx
import React from 'react';
import {render, screen} from '@testing-library/react';
import ProductListPage from '../pages/ProductListPage/ProductListPage.jsx';
import '@testing-library/jest-dom'

jest.mock('../components/ProductCard/ProductCard', () => {
    return (() => <div>mockModuleName</div>);
});
describe('ProductListPage', () => {
    test('renders product list heading', () => {
        render(<ProductListPage />);
        const headingElement = screen.getByRole('heading', { level: 1 });
        expect(headingElement).toBeInTheDocument();
        expect(headingElement).toHaveTextContent(/Product List/i);
    });

    test('renders at least 15 product cards', async () => {
        render(<ProductListPage />);
        const productCards = await screen.findAllByText('mockModuleName');
        expect(productCards.length).toBeGreaterThanOrEqual(15);
    });
});

```

3. 搭建一个前端项目

用Vite搭建，注意统一语言typescript/javascript，以及包管理器可以用最新的pnpm。package.json看上去像后端的build.gradle。 测试配置的是Jest，安装后使用以下命令： 并且更新package.json即可， 无需再配置什么测试配置文件。

```jsx
import '@testing-library/jest-dom'
```

4. 语言共存

我用vite搭建的是typescript, 入口文件也是typescript(我把main.tsx改成了index.tsx)。 但之后的page等我都用的jsx, 在入口文件引入时发现tsx引入不了jsx，可以采用以下操作，不必将tsx改成jsx，而是共存： https://blog.csdn.net/yu359697395/article/details/78585267

```jsx
**{
"compilerOptions": {
"outDir": "./built",
"allowJs": true,        //
"target": "es5"
},
"include": [
"./src/**/*"
]
}

```

5. 什么是组件 什么是props

函数组件：函数组件是无状态的,没有生命周期方法,只负责接收数据(props)并渲染UI

```jsx
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```

箭头函数定义的组

```jsx
const ProductListPage = () => {...}
```

在 React 中，我们不应该直接修改状态变量，而是使用 **`setState`** 或 **`useState`** 提供的更新函数来更新状态，而不是直接修改状态变量。这样可以确保状态的更新是可控的，并且 React 可以正确地处理重新渲染。

6. 分页展示

比如下面这段代码，当 currentPage 状态更新后，React 会重新渲染组件，使用新的 currentPage 值计算出新的 startIndex、endIndex 和 currentProducts。所以每页展示的内容不一样

```jsx
const ProductListPage = () => {
    //变量currentPage初始值为1  函数setCurrentPage用于更新currentPage
    const [currentPage, setCurrentPage] = useState(1);
    //每页展示的产品数量
    const itemsPerPage = 5;
    //向上取整 页数
    const totalPages = Math.ceil(products.length / itemsPerPage);

    const startIndex = (currentPage - 1) * itemsPerPage;
    const endIndex = startIndex + itemsPerPage;
    //切片
    const currentProducts = products.slice(startIndex, endIndex);

    const handlePageChange = (pageNumber) => {
        // 会更新currentPage,当 currentPage 状态更新后，React 会重新渲染组件，使用新的 currentPage 值计算出新的 startIndex、endIndex 和 currentProducts。
        setCurrentPage(pageNumber);
    };

    return (
        <div className="product-list-page">
            <h1 className="product-list-heading">Product List</h1>
            <div className="product-list-container">
                {currentProducts.map((product) => (
                    <ProductCard
                        key={product.id}
                        product={product}
                        data-testid="product-card"
                    />
                ))}
            </div>
            {/*分页按钮*/}
            <div className="pagination">
                {Array.from({ length: totalPages }, (_, i) => (
                    <button
                        key={i + 1}
                        onClick={() => handlePageChange(i + 1)}
                        className={currentPage === i + 1 ? 'active' : ''}
                    >
                        {i + 1}
                    </button>
                ))}
            </div>
        </div>
    );
};
```

7. npm install会把所有import的东西都install吗？
   如果你导入的模块没有在package.json中列出,那么npm install将不会安装它。你需要手动将该模块添加到dependencies或devDependencies中,然后再运行npm install。