---
title: Hexo+ Github搭建一个个人博客
date: 2024-05-21 15:18:47
tags: 日常记录
---

### 经典三层架构

### DDD分层架构

其实之前项目上用的就是DDD，但是到今天我才从全貌去理解它，用一个订单系统举例子。 一个订单会包含多个订单项，订单的总金额需要是订单项金额的累计，因此 Order 与 OrderLine不应是两个单独的类，  用 `Aggregate` 这一概念来写Order， 外部通过Order来改OrderLine，避免错误。

也就是说，聚合根的存在是为了： 外部对象只能通过聚合根来访问和修改聚合内部的数据。现在再回到这个架构的名字：领域驱动开发

**包位置： domain**

包位置： domain/models

Entity

- Order
- OrderLine

Value Object（属性描述）

- EffectivePeriod
- Address

Aggregate Root ： 它定义了一个聚合(Aggregate)的边界,并作为外部对象访问和修改聚合内部对象的唯一入口。

- InterestRateRequest 可以理解成OrderAggregate

Domain Service (领域层服务专注于实现核心的业务逻辑)

包位置： domain/service

- OrderService

包位置： domain/repository

- InterestRateRepository

其实关于这一层，我忘记了当时项目上用的聚合根的场景了。还有关于领域服务，我们项目上似乎是没有领域服务的，业务逻辑都是写在应用层的。 只能说这里再之后多看看代码，具体场景具体分析了。这里我有的用了一些之前项目上的代码，已经经过脱敏处理。

```java
public class Order {
    private OrderId id;
    private List<OrderLine> orderLines;
    private Money totalAmount;
    private Address shippingAddress;

    public void addOrderLine(OrderLine orderLine) {
        // 添加订单项
    }

    public void calculateTotalAmount() {
        // 计算订单总金额
    }
}
```

聚合根：

```kotlin
interface AggregateRoot<T : AggregateRoot<T>> {
  val id: Id<T>
}
```

```kotlin
data class InterestRateRequest(
  val effectivePeriod: String,
  val rate: BigDecimal,
  override val id: String
) : AggregateRoot<InterestRateRequest> {

  companion object {
    private val log = LoggerFactory.getLogger(InterestRateRequest::class.java)

    fun create(
      rate: BigDecimal,
    ): InterestRateRequest {
      if (...) {
        log.warn("...")
        throw BusinessException(
          "XXX",
          "effective period is not match last one"
        )
      }

      if (rate > RATE_UPPER_LIMIT || rate < RATE_LOWER_LIMIT) {
        log.warn("...")
        throw BusinessException(
          "AAA",
          "interest rate not input more than 100% or less than 0%"
        )
      }
      val startOfTomorrow = LocalDate.now().atStartOfDay().plusDays(1)
      if (approvedOn.isBefore(startOfTomorrow)) {
        log.warn("...")
        throw BusinessException(
          "BBB",
          "approved on must be after tomorrow and beyond"
        )
      }

      return InterestRateRequest(
        effectivePeriod = "effectivePeriod",
        id = "id"
      )
    }
  }
}
```

下单和支付的核心业务逻辑

```java

@Service
public class OrderService {

    public void placeOrder(OrderAggregate orderAggregate, PaymentDetails paymentDetails) {
        // 执行下单业务逻辑
        Order order = orderAggregate.getOrder();
        order.setStatus(OrderStatus.PLACED);

        // 执行支付逻辑
        processPayment(order, paymentDetails);

        // 其他下单相关的业务逻辑
        // ...
    }

    private void processPayment(Order order, PaymentDetails paymentDetails) {
        // 调用支付网关进行支付
        boolean paymentSuccessful = callPaymentGateway(order, paymentDetails);

        if (paymentSuccessful) {
            order.setStatus(OrderStatus.PAID);
            // 执行其他支付成功后的逻辑
            // ...
        } else {
            order.setStatus(OrderStatus.PAYMENT_FAILED);
            // 执行支付失败后的逻辑
            // ...
        }
    }
}
```

```java
interface FileRepository {
  fun save(file: File)
}
```

包位置：application

- PlaceOrderService   （之前在项目组用UseCase代替这里的Service）

```java
@Service
public class PlaceOrderService {
    private final OrderService orderService;
    private final OrderRepository orderRepository;

    public PlaceOrderService(OrderService orderService, OrderRepository orderRepository) {
        this.orderService = orderService;
        this.orderRepository = orderRepository;
    }

    @Transactional
    public void placeOrder(PlaceOrderRequest request) {
        OrderId orderId = OrderId.next();
        OrderAggregate orderAggregate = new OrderAggregate(orderId);
        orderAggregate.setShippingAddress(request.getShippingAddress());
        request.getOrderLines().forEach(ol -> orderAggregate.addOrderLine(ol.getProduct(), ol.getQuantity()));
        orderAggregate.submitOrder();

        orderService.placeOrder(orderAggregate, request.getPaymentDetails());

        orderRepository.save(orderAggregate);
    }
}
```

包位置： infrastructure

包位置： infrastructure/repository

- JooqInterestRateRequestRepository

```java

@Repository
class JooqInterestRateRequestRepository(
  private val dslContext: DSLContext,
) : InterestRateRequestRepository {
  val mapper = MapperUtils.getMapper<InterestRateRequestMapper>()

  override fun save(interestRateRequest: InterestRateRequest) {
    mapper
      .convertToRecord(interestRateRequest, dslContext.newRecord(PT_INTEREST_RATE_REQUEST))
      .let { dslContext.batchInsert(it).execute() }
  }
 }
```

controller层都是一样的，我就省略不写了。我记得当时有一种情况，如果repository要对整个聚合根进行操作。 如果不是对整个聚合根操作，是放到另一个地方的。例子如下：    并不需要查出来整个聚合根

包位置: querymodel

包位置：querymodel/repository

包位置：querymodel/condition  所有可能的查询条件组合而成的数据模型

- CaseDocumentsCondition

包位置：querymodel/querymodel  想查出来的数据模型

- CaseDocumentQueryModel

```kotlin
data class CaseDocumentQueryModel(
  val documentType: CaseDocumentType,
  val filename: String,
  val uploadedOn: LocalDateTime,
  val uploadedBy: UUID,
  val usedIn: CasePhase,
  val status: CaseDocumentStatus,
  val caseDocumentId: UUID
)
```

```kotlin
data class CaseDocumentsCondition(
  val page: Int,
  val size: Int,
  val filenameSearchCondition: String? = null,
  val typeSearchCondition: String? = null,
  val startUploadedOnSearchCondition: LocalDate? = null,
  val uploadedBySearchCondition: String? = null,
  val statusSearchCondition: String? = null,
  val usedInSearchCondition: String? = null,
  val endUploadedOnSearchCondition: LocalDate? = null,
)
```

```kotlin
interface FileInfoQueryRepository {
  fun findDocumentBy(caseId: UUID, condition: CaseDocumentsCondition): CaseDocumentQueryModel
}
```

Anyway, 项目上的DDD架构看起来会稍微不一样一点。比如domain service没怎么用到，但是domain还会放repository的接口。  聚合根的使用也是如此，好多实体还有一个接口放在domain里面（不知道为啥)。 实体里面是有方法的（比如在request这个实体里，封装了判断rate是否正确，不正确报错，正确才返回真正的实体。  关于这一块，我记得也是有说法的。比如封装到实体里，那么从初始化开始，就不会生成不对的这个实体。 如果把这些判断封装到别的地方，会对逻辑有一些不同的影响）。

总结来说，DDD比起三层经典架构来说，多了一层domain，来放置抽象的infrastructure层的接口。 现在再看这张图，就觉得更理解一些了：

![图片](/images/DDD1.png "Arch")
DDD中多的这个domain的包：

在DDD中,强调建立一种统一的领域语言。在这个例子中,开发团队和银行业务专家需要就"账户"、"存款"、"贷款"等概念达成共识,形成一套统一的术语和定义。例如,他们可能会约定:

- "账户"指的是客户在银行开立的账号,包括存款账户和贷款账户。
- "存款"指的是客户存入银行的资金。
- "贷款"指的是银行向客户发放的借款。

通过建立这种统一的领域语言,开发人员和业务专家就能够在同一个语义基础上进行交流和讨论,减少理解上的偏差。当开发人员在编写代码时,他们可以直接使用这些约定好的术语,而不需要进行"翻译"。这样一来,代码就能够更好地反映业务领域的概念,从而确保系统符合真实的业务需求。

【未完待续..】