<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>《Spring 4.x 企业应用开发实战》读书笔记 | Anne&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="第一章源代码：https:&#x2F;&#x2F;github.com&#x2F;seriouszyx&#x2F;LearnSpring&#x2F;tree&#x2F;master&#x2F;source%20codehttp:&#x2F;&#x2F;iteye.com 为什么云的兴起使得消除开发者和运营者的隔阂更重要？什么是运营者？  传统上,开发者和运营者是分开的两个角色。开发者完成应用程序开发后,就把代码交给运营者。运营者需要将代码部署到服务器上,并负责后续的系统运维工作。">
<meta property="og:type" content="article">
<meta property="og:title" content="《Spring 4.x 企业应用开发实战》读书笔记">
<meta property="og:url" content="https://anne-aaa.github.io/2024/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Anne&#39;s Blog">
<meta property="og:description" content="第一章源代码：https:&#x2F;&#x2F;github.com&#x2F;seriouszyx&#x2F;LearnSpring&#x2F;tree&#x2F;master&#x2F;source%20codehttp:&#x2F;&#x2F;iteye.com 为什么云的兴起使得消除开发者和运营者的隔阂更重要？什么是运营者？  传统上,开发者和运营者是分开的两个角色。开发者完成应用程序开发后,就把代码交给运营者。运营者需要将代码部署到服务器上,并负责后续的系统运维工作。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-05-20T16:00:00.000Z">
<meta property="article:modified_time" content="2024-05-21T07:48:16.346Z">
<meta property="article:author" content="Anne">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Anne's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 7.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Anne&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS Feed"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="Search"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://anne-aaa.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-读书笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2024/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2024-05-20T16:00:00.000Z" itemprop="datePublished">2024-05-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      《Spring 4.x 企业应用开发实战》读书笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><p>源代码：<a target="_blank" rel="noopener" href="https://github.com/seriouszyx/LearnSpring/tree/master/source%20code">https://github.com/seriouszyx/LearnSpring/tree/master/source%20code</a><br><a target="_blank" rel="noopener" href="http://iteye.com/">http://iteye.com</a></p>
<h5 id="为什么云的兴起使得消除开发者和运营者的隔阂更重要？"><a href="#为什么云的兴起使得消除开发者和运营者的隔阂更重要？" class="headerlink" title="为什么云的兴起使得消除开发者和运营者的隔阂更重要？"></a>为什么云的兴起使得消除开发者和运营者的隔阂更重要？</h5><p>什么是运营者？</p>
<ul>
<li>传统上,开发者和运营者是分开的两个角色。开发者完成应用程序开发后,就把代码交给运营者。运营者需要将代码部署到服务器上,并负责后续的系统运维工作。</li>
</ul>
<ol>
<li><p>云环境下应用程序的复杂性增加。现代软件项目通常依赖数百个外部依赖项和多个关键服务,运行在云端。开发者需要熟悉和管理大量云服务、工具和平台,工作负担加重。这就需要开发者和运营者密切协作,共同分担责任。</p>
</li>
<li><p>DevOps文化的兴起。当今科技公司普遍采用”开发者全权负责”的DevOps文化,开发者不仅负责编码,还参与测试、部署、维护等环节。这种共同责任模式要求开发者和运营者的角色高度融合。</p>
</li>
</ol>
<h5 id="什么功能用传统的OOP不易实现，用AOP却可以轻松应对？"><a href="#什么功能用传统的OOP不易实现，用AOP却可以轻松应对？" class="headerlink" title="什么功能用传统的OOP不易实现，用AOP却可以轻松应对？"></a>什么功能用传统的OOP不易实现，用AOP却可以轻松应对？</h5><ul>
<li>面向对象编程(OOP)不太擅长处理的是一些与核心业务逻辑无关,但又需要在多个模块中重复出现的代码,我们称之为”横切关注点”。而面向切面编程(AOP)就是为了解决这个问题而诞生的。 AOP主要应用场景包括日志记录,性能统计,安全控制,事务处理,异常处理等等。”这些功能虽然不是核心业务逻辑,但又需要在许多模块中重复实现,使用传统OOP的做法就会导致代码的冗余和低内聚。</li>
</ul>
<p>IOC和AOP是Spring以来的根本</p>
<ul>
<li>传统编程用new来创建，现在交给Spring容器注入。</li>
<li>传统编程中,对象创建对象,并且负责对象的生命周期。而在IOC模式下,由容器控制对象的创建、初始化以及实例的生命周期。对象本身只需要提供标准的构造函数即可。<br>![[Pasted image 20240508151528.png]]</li>
</ul>
<h5 id="数据访问和集成："><a href="#数据访问和集成：" class="headerlink" title="数据访问和集成："></a>数据访问和集成：</h5><p>数据有多种表现形式，如数据表、XML、消息。每种数据形式拥有不同的数据访问技术（数据表的访问可以直接通过JDBC，JOOQ，也可以通过Hibernate或MyBatis）</p>
<ul>
<li>这些都是不同的实现技术，但是同样的解决问题。比如不同的测试框架</li>
<li>Spring建立起了和数据形式及访问技术无关的统一的DAO层<br>eg.   首先,定义一个技术无关的DAO接口:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123; List&lt;User&gt; <span class="title function_">findAll</span><span class="params">()</span>; User <span class="title function_">findById</span><span class="params">(<span class="type">int</span> id)</span>; <span class="comment">// ... &#125;</span></span><br></pre></td></tr></table></figure>
  然后,使用JOOQ实现这个DAO接口</li>
</ul>
<h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>基于Spring的Web应用</p>
<p>JSP是一种动态页面，是传统的MVC，要返回给浏览器的动态页面。<br>什么是Web容器？</p>
<ol>
<li>Web容器能够解析并执行动态资源(如JSP、Servlet),而不仅仅是返回静态HTML页面。</li>
<li>常见的Web容器有Tomcat、Jetty等,它们通常以嵌入式的方式运行在应用程序中。</li>
<li>在微服务架构中,轻量级的Web容器(如Tomcat)被广泛使用,因为它们占用较少资源,易于部署和集成。</li>
</ol>
<p>Jetty</p>
<ul>
<li>IDEA的免费社区版本本身不直接支持开发Web项目,需要额外配置Web服务器环境。而Jetty作为一个轻量级的嵌入式Web服务器,可以很方便地集成到IDEA中,为Web项目提供运行环境.</li>
<li>与传统的Web服务器(如Tomcat)相比,Jetty更加轻量级,占用系统资源更少,启动速度也更快。这使得在开发阶段使用Jetty更加高效</li>
</ul>
<p>Spring的声明式事务</p>
<ul>
<li>Spring的声明式事务管理就像是安排了一个”监工”在旁边监督,确保付款的每个步骤都正确执行。如果中间出现任何问题,这个”监工”会立即停止后续步骤,并让整个过程回到最初状态,避免数据不一致。使用Spring声明式事务,我们不需要手动编写监控和回滚事务的代码,只需在关键的业务方法上标注@Transactional注解,Spring就会自动为这些方法增加事务管理的能力,确保事务either全部成功或全部失败回滚,不会出现中间状态。</li>
</ul>
<h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>Spring Boot</p>
<ul>
<li>内嵌Tomcat和Jetty容器，不需要部署WAR 文件到Web容器就可独立运行 应用</li>
</ul>
<p>jar包和war包是什么，为什么要将程序打包成他们？</p>
<h5 id="运维功能"><a href="#运维功能" class="headerlink" title="运维功能"></a>运维功能</h5><ul>
<li>当应用部署到生产环境时，需要各种运维相关的功能 的支持，如监控应用的各种性能指标、运行信息和应用状态等。SpringBoot 对这些运维监控相关的类库 进 行 了整 合 ， 形 成 了一 个功 能 完 备 和 可 定 制 的 启 动 器 ， 称 为 A c t u a t o r 。<br>基于Spring Boot应用，添加监控功能非常简单，只需在应用的pom.xml 文件中添 加spring-boot-starter-actuator 依赖即可</li>
<li>Spring Boot 默认提供的健康检查关键服务。这些服务都可以在 application.properties 的management .health. *选项中进行配置</li>
</ul>
<p>pom.xml与application.properties</p>
<ul>
<li><ol>
<li>pom.xml文件: 相当于build.gradle<br>它是Maven项目的核心配置文件,用于定义项目的构建配置。<br> pom.xml文件中包含了项目的依赖库、插件、构建生命周期等信息。</li>
</ol>
</li>
<li><ol start="2">
<li><strong>application.properties文件</strong>:<br>它是Spring Boot等Java应用程序的配置文件,用于配置应用程序的运行时参数。<br>application.properties文件中包含了数据库连接信息、服务器端口、日志级别等配置项。</li>
</ol>
</li>
</ul>
<h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p>IOC：</p>
<ul>
<li>IOC这个概念不够清晰，即某 一接又具体实现类的选择控制权从调用类中移除， 转交给第 三方决定，即由Spring容器借由Bean配置来进行控制。<br>DI：</li>
<li>因为IoC确实不够开门见山，因此业界曾进行了广泛的讨论，最终软件界的泰斗级 人物MartinFowler 提出了DI (DependencyInjection，依赖注入)的概念用来代替IoC， 即让调用类对某一接又实现类的依赖关系由第三方 (容器或协作类)注入，以移除调用 类 对 某 一接 又 实 现 类 的 依 赖 。 “ 依 赖 注 入 ” 这 个 名 词 显 然 比 “ 控 制 反 转 ” 直 接 明 了 、 易 于理解。</li>
</ul>
<p>构造注入 与 属性注入：</p>
<ul>
<li>并非每个场景都需要它的时候，与构造注入它就显得不太妥当，于是用属性注入。属性注入可以有选择地通过Setter 方法完成调用类所需依赖的注入，更加灵活方便。 也就是”按需注入”<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造注入革席的具体饰演者 </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MoAttack</span> <span class="params">(GeLi geli)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.geli = geli;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//属性注入</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGeli</span> <span class="params">(GeLi geli)</span> &#123;</span><br><span class="line">thisgeli = geli;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>JVM</p>
<ul>
<li>JVM将Java源代码编译成字节码,然后将字节码解释成机器码,以便在不同的平台上运行。这使得Java程序可以在不同的平台上运行,而不需要重新编译。</li>
<li>JVM装载类时使用 “全盘负责委托机制”，“ 全盘负责” 是指当一个ClassLoader 装 载 一 个 类 时 ， 除 非 显 式 地 使 用 另一 个 C l a s s L o a d e r ， 该 类 所 依 赖 及 引 用 的 类 也 由 这 个 ClassLoader 载</li>
</ul>
<p>Jar包</p>
<ul>
<li>jar包是由Java语言编写的程序,将其编译后的.class文件和其他必要资源文件打包成一个文件,以便于分发和部署。</li>
</ul>
<p>ClassLoader:</p>
<ul>
<li>类装载器 就是 寻找类的字节码文件并构造 出 类 在 J V M 内 部 表 示 对 象 的 组 件 。 在 J a v a 中，类装载器把一个类装入J M中。</li>
</ul>
<p>JDK：</p>
<ul>
<li>JDK(Java Development Kit)是Java语言的开发工具包,包含了Java编译器(将Java源代码编译成.class文件,然后执行这些.class文件。)、Java运行时环境(执行Java程序)和其他开发工具(如debugger、profiler)。</li>
</ul>
<p>BeanFactory 是Spring 框架的基础设 施，面向Spring 本身:ApplicationContext 面向使用Spring 框架的开发者，几乎所有的 应用场合都可以直接使用ApplicationContext 而非底层的BeanFactory</p>
<h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h5 id="1-书中用到了1️⃣配置文件来写这个class是一个bean，但实际项目上并没有这样做，而是好像直接用2️⃣注解引入，这是什么意思？"><a href="#1-书中用到了1️⃣配置文件来写这个class是一个bean，但实际项目上并没有这样做，而是好像直接用2️⃣注解引入，这是什么意思？" class="headerlink" title="1. 书中用到了1️⃣配置文件来写这个class是一个bean，但实际项目上并没有这样做，而是好像直接用2️⃣注解引入，这是什么意思？"></a>1. 书中用到了1️⃣配置文件来写这个class是一个bean，但实际项目上并没有这样做，而是好像直接用2️⃣注解引入，这是什么意思？</h5><pre><code>- 从Spring 2.5开始,引入了基于注解(@Annotation)的配置方式。开发者可以直接在Bean类上使用@Component、@Service、@Repository、@Controller等注解将其声明为Bean,而不需要在XML中重复配置。这种方式更加简洁、高效,也是当前推荐的配置方式。
</code></pre>
<p>eg.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span> <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123; </span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">getUserName</span><span class="params">(<span class="type">int</span> userId)</span> &#123; <span class="comment">// 查询用户名的逻辑 return &quot;John Doe&quot;; &#125; </span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>通过<code>@Service</code>注解,Spring就可以自动扫描到这个类,并将其注册为一个Bean,名称默认为”userService”(类名的第一个字母小写)。接下来,如果我们有另一个组件需要使用UserService,可以使用<code>@Autowired</code>注解自动注入:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired; <span class="keyword">import</span> org.springframework.stereotype.Component; </span><br><span class="line"><span class="meta">@Component</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printUserName</span><span class="params">(<span class="type">int</span> userId)</span> &#123; </span><br><span class="line"> <span class="type">String</span> <span class="variable">userName</span> <span class="operator">=</span> userService.getUserName(userId); System.out.println(<span class="string">&quot;User name: &quot;</span> + userName); </span><br><span class="line"> &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>@Component</code>注解将<code>UserController</code>标记为一个Bean。</li>
<li><code>@Autowired</code>注解自动将<code>UserService</code>的Bean注入到<code>userService</code>字段中。</li>
</ol>
<p>通过这种方式,Spring可以自动扫描和注册所有标记了<code>@Component</code>、<code>@Service</code>等注解的类作为Bean,并自动注入它们之间的依赖关系。</p>
<p>如 果 容 器 中 有 一 个 以 上匹 配 的 B e a n 时 ， 则 可 以 通 过 @ Q u a l i f i e r 注 解 限 定 B e a n 的 名 称，<br>一般 情 况 下 ， 在 S p r i n g 容 器 中 大 部 分 B e a n 都 是 单 实 例 的 ， 所 以 一般 无 须 通 过@Repository、@Service 等注解的value 属性为Bean 指定名称，也无须使用@Qualifier 注解按名称进行注入。</p>
<p>还可以通过3️⃣@Configuration来为一个POJO 标注为配置类，里面就可以定义@Bean(比如Service Bean, Dao Bean)，以及Bean的实例化逻辑</p>
<h5 id="2-关于Bean的作用域："><a href="#2-关于Bean的作用域：" class="headerlink" title="2. 关于Bean的作用域："></a>2. 关于Bean的作用域：</h5><p>首先要理解”单例模式”，一个类只有一个实例，适合用来管理共享资源。s i n g l e t o n 的 B e a n 在 同 一S p r i n g I o C 容 器 中 只 有 一个 实例。<br>S p r i n g 的 A p p l i c a t i o n C o n t e x t 容 器 在 启 动 时 ，自 动 实 例 化 所 有 s i n g l e t o n 的Bean 并缓存于容器中。虽然启动时会花费一些时间，但它带来两个好处:首先，对 Bean提前进行实例化操作会及早发现一些潜在的配置问题</p>
<p>在 默 认 情 况 下， S p r i n g 容 器 在 启 动 时 不 实 例 化 p r o t o t y p e 的 B e a n<br>request作用域<br>顾 名 思 义 ， r e q u e s t 作 用 域 的 B e a n 对 应 一个 H T T P 请 求 和 生 命 周 期</p>
<p>什么场景下用单例Bean,什么场景下用prototype的bean？</p>
<ul>
<li>想象一下,我们有一个学校,学校里有很多老师和学生。每个老师都有一个自己的教室,里面有一个小黑板。如果我们使用单例bean来表示小黑板,那就意味着所有老师都共享同一个小黑板。这样的话,如果张老师在小黑板上写了”2+3&#x3D;5”,李老师过来上课时,小黑板上还是显示”2+3&#x3D;5”,这就会造成混乱。相反,如果我们使用session bean来表示小黑板,每个老师都会有自己专属的小黑板。这样,张老师在自己的小黑板上写”2+3&#x3D;5”,李老师在自己的小黑板上写”5+7&#x3D;12”,两个老师之间就不会互相影响了。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://anne-aaa.github.io/2024/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" data-id="clxbzt3jj00036xpo7dr2ce1d" data-title="《Spring 4.x 企业应用开发实战》读书笔记" class="article-share-link"><span class="fa fa-share">Share</span></a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2024/05/21/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%81%9A%E5%89%8D%E7%AB%AF%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          前端项目中遇到的问题
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AWS/" rel="tag">AWS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/" rel="tag">日常记录</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AWS/" style="font-size: 10px;">AWS</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 10px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 20px;">后端</a> <a href="/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/" style="font-size: 10px;">日常记录</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/06/">June 2024</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/05/">May 2024</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2024/06/12/backend/AWS%20SAA%E7%9F%A5%E8%AF%86%E7%82%B9%E8%81%94%E5%90%88/">AWS SAA知识点联合</a>
          </li>
        
          <li>
            <a href="/2024/05/24/backend/%E6%9E%B6%E6%9E%84/">架构</a>
          </li>
        
          <li>
            <a href="/2024/05/21/Hexo+%20Github%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">Hexo+ Github搭建一个个人博客</a>
          </li>
        
          <li>
            <a href="/2024/05/21/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%81%9A%E5%89%8D%E7%AB%AF%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/">前端项目中遇到的问题</a>
          </li>
        
          <li>
            <a href="/2024/05/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">《Spring 4.x 企业应用开发实战》读书笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2024 Anne<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>